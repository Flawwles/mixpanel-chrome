{"version":3,"sources":["../node_modules/query-selector-shadow-dom/src/normalize.js","../node_modules/query-selector-shadow-dom/src/querySelectorDeep.js","inject.js"],"names":["normalizeSelector","sel","saveUnmatched","unmatched","tokens","length","test","push","match","regex","prev_match_idx","state","next_match_idx","not_escaped_pattern","whitespace_pattern","state_patterns","trim","lastIndex","exec","substr","substring","RegExp","pop","charAt","join","querySelectorAllDeep","selector","root","document","allElements","_querySelectorDeep","querySelectorDeep","findMany","lightElement","querySelector","head","createShadowRoot","attachShadow","selectionsToMake","splitByCharacterUnlessQuoted","reduce","acc","minimalSelector","splitSelector","replace","filter","entry","map","possibleElementsIndex","possibleElements","collectAllElementsDeep","findElements","findMatchingElement","concat","find","querySelectorAll","element","position","parent","foundElement","isDocumentNode","foundMatch","matches","reversedParts","reverse","newParent","part","findParentOrHost","character","p","c","sQuote","quote","a","node","nodeType","Node","DOCUMENT_FRAGMENT_NODE","DOCUMENT_NODE","parentNode","host","cachedElements","findAllElements","nodes","el","i","shadowRoot","testDom","getTitle","id","makeRequest","qid","Promise","jsonData","eninityTitle","entities","sitelinks","enwiki","title","resolve","console","log","ID","fetch","wikidata","json","wikidataJson","ids","findAllIds","forEach","childNodes","TEXT_NODE","textNode","textContent","split","item","eninityArry","eninityId","preString","createObject","name","all","getData","then","data"],"mappings":"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","file":"inject.js","sourceRoot":"../src","sourcesContent":["/* istanbul ignore file */\n\n\n// normalize-selector-rev-02.js\n/*\n  author: kyle simpson (@getify)\n  original source: https://gist.github.com/getify/9679380\n\n  modified for tests by david kaye (@dfkaye)\n  21 march 2014\n\n  rev-02 incorporate kyle's changes 3/2/42014\n*/\n\nexport function normalizeSelector(sel) {\n  // save unmatched text, if any\n  function saveUnmatched() {\n    if (unmatched) {\n      // whitespace needed after combinator?\n      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {\n        tokens.push(\" \");\n      }\n\n      // save unmatched text\n      tokens.push(unmatched);\n    }\n  }\n\n  var tokens = [],\n    match,\n    unmatched,\n    regex,\n    state = [0],\n    next_match_idx = 0,\n    prev_match_idx,\n    not_escaped_pattern = /(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,\n    whitespace_pattern = /^\\s+$/,\n    state_patterns = [\n      /\\s+|\\/\\*|[\"'>~+\\[\\(]/g, // general\n      /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // [..] set\n      /\\s+|\\/\\*|[\"'\\[\\]\\(\\)]/g, // (..) set\n      null, // string literal (placeholder)\n      /\\*\\//g, // comment\n    ];\n  sel = sel.trim();\n\n  while (true) {\n    unmatched = \"\";\n\n    regex = state_patterns[state[state.length - 1]];\n\n    regex.lastIndex = next_match_idx;\n    match = regex.exec(sel);\n\n    // matched text to process?\n    if (match) {\n      prev_match_idx = next_match_idx;\n      next_match_idx = regex.lastIndex;\n\n      // collect the previous string chunk not matched before this token\n      if (prev_match_idx < next_match_idx - match[0].length) {\n        unmatched = sel.substring(\n          prev_match_idx,\n          next_match_idx - match[0].length\n        );\n      }\n\n      // general, [ ] pair, ( ) pair?\n      if (state[state.length - 1] < 3) {\n        saveUnmatched();\n\n        // starting a [ ] pair?\n        if (match[0] === \"[\") {\n          state.push(1);\n        }\n        // starting a ( ) pair?\n        else if (match[0] === \"(\") {\n          state.push(2);\n        }\n        // starting a string literal?\n        else if (/^[\"']$/.test(match[0])) {\n          state.push(3);\n          state_patterns[3] = new RegExp(match[0], \"g\");\n        }\n        // starting a comment?\n        else if (match[0] === \"/*\") {\n          state.push(4);\n        }\n        // ending a [ ] or ( ) pair?\n        else if (/^[\\]\\)]$/.test(match[0]) && state.length > 0) {\n          state.pop();\n        }\n        // handling whitespace or a combinator?\n        else if (/^(?:\\s+|[~+>])$/.test(match[0])) {\n          // need to insert whitespace before?\n          if (\n            tokens.length > 0 &&\n            !whitespace_pattern.test(tokens[tokens.length - 1]) &&\n            state[state.length - 1] === 0\n          ) {\n            // add normalized whitespace\n            tokens.push(\" \");\n          }\n\n          // case-insensitive attribute selector CSS L4\n          if (\n            state[state.length - 1] === 1 &&\n            tokens.length === 5 &&\n            tokens[2].charAt(tokens[2].length - 1) === \"=\"\n          ) {\n            tokens[4] = \" \" + tokens[4];\n          }\n\n          // whitespace token we can skip?\n          if (whitespace_pattern.test(match[0])) {\n            continue;\n          }\n        }\n\n        // save matched text\n        tokens.push(match[0]);\n      }\n      // otherwise, string literal or comment\n      else {\n        // save unmatched text\n        tokens[tokens.length - 1] += unmatched;\n\n        // unescaped terminator to string literal or comment?\n        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {\n          // comment terminator?\n          if (state[state.length - 1] === 4) {\n            // ok to drop comment?\n            if (\n              tokens.length < 2 ||\n              whitespace_pattern.test(tokens[tokens.length - 2])\n            ) {\n              tokens.pop();\n            }\n            // otherwise, turn comment into whitespace\n            else {\n              tokens[tokens.length - 1] = \" \";\n            }\n\n            // handled already\n            match[0] = \"\";\n          }\n\n          state.pop();\n        }\n\n        // append matched text to existing token\n        tokens[tokens.length - 1] += match[0];\n      }\n    }\n    // otherwise, end of processing (no more matches)\n    else {\n      unmatched = sel.substr(next_match_idx);\n      saveUnmatched();\n\n      break;\n    }\n  }\n\n  return tokens.join(\"\").trim();\n}\n","/**\n * @author Georgegriff@ (George Griffiths)\n * License Apache-2.0\n */\n\nimport { normalizeSelector } from './normalize';\n\n/**\n* Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth\n*\n* Don't have to specify all shadow roots to button, tree is travered to find the correct element\n*\n* Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');\n*\n* Example should work on chrome://downloads outputting the remove button inside of a download card component\n*\n* Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^=\"https://\"]');\n*\n* Another example querySelectorAllDeep('#downloads-list div#title-area + a');\ne.g.\n*/\nexport function querySelectorAllDeep(selector, root = document, allElements = null) {\n    return _querySelectorDeep(selector, true, root, allElements);\n}\n\nexport function querySelectorDeep(selector, root = document, allElements = null) {\n    return _querySelectorDeep(selector, false, root, allElements);\n}\n\nfunction _querySelectorDeep(selector, findMany, root, allElements = null) {\n    selector = normalizeSelector(selector)\n    let lightElement = root.querySelector(selector);\n\n    if (document.head.createShadowRoot || document.head.attachShadow) {\n        // no need to do any special if selector matches something specific in light-dom\n        if (!findMany && lightElement) {\n            return lightElement;\n        }\n\n        // split on commas because those are a logical divide in the operation\n        const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');\n\n        return selectionsToMake.reduce((acc, minimalSelector) => {\n            // if not finding many just reduce the first match\n            if (!findMany && acc) {\n                return acc;\n            }\n            // do best to support complex selectors and split the query\n            const splitSelector = splitByCharacterUnlessQuoted(minimalSelector\n                    //remove white space at start of selector\n                    .replace(/^\\s+/g, '')\n                    .replace(/\\s*([>+~]+)\\s*/g, '$1'), ' ')\n                    // filter out entry white selectors\n                    .filter((entry) => !!entry)\n                    // convert \"a > b\" to [\"a\", \"b\"]\n                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));\n\n            const possibleElementsIndex = splitSelector.length - 1;\n            const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1]\n            const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);\n            const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);\n            if (findMany) {\n                acc = acc.concat(possibleElements.filter(findElements));\n                return acc;\n            } else {\n                acc = possibleElements.find(findElements);\n                return acc || null;\n            }\n        }, findMany ? [] : null);\n\n\n    } else {\n        if (!findMany) {\n            return lightElement;\n        } else {\n            return root.querySelectorAll(selector);\n        }\n    }\n\n}\n\nfunction findMatchingElement(splitSelector, possibleElementsIndex, root) {\n    return (element) => {\n        let position = possibleElementsIndex;\n        let parent = element;\n        let foundElement = false;\n        while (parent && !isDocumentNode(parent)) {\n            let foundMatch = true\n            if (splitSelector[position].length === 1) {\n                foundMatch = parent.matches(splitSelector[position]);\n            } else {\n                // selector is in the format \"a > b\"\n                // make sure a few parents match in order\n                const reversedParts = ([]).concat(splitSelector[position]).reverse()\n                let newParent = parent\n                for (const part of reversedParts) {\n                    if (!newParent || !newParent.matches(part)) {\n                        foundMatch = false\n                        break\n                    }\n                    newParent = findParentOrHost(newParent, root);\n                }\n            }\n\n            if (foundMatch && position === 0) {\n                foundElement = true;\n                break;\n            }\n            if (foundMatch) {\n                position--;\n            }\n            parent = findParentOrHost(parent, root);\n        }\n        return foundElement;\n    };\n\n}\n\nfunction splitByCharacterUnlessQuoted(selector, character) {\n    return selector.match(/\\\\?.|^$/g).reduce((p, c) => {\n        if (c === '\"' && !p.sQuote) {\n            p.quote ^= 1;\n            p.a[p.a.length - 1] += c;\n        } else if (c === '\\'' && !p.quote) {\n            p.sQuote ^= 1;\n            p.a[p.a.length - 1] += c;\n\n        } else if (!p.quote && !p.sQuote && c === character) {\n            p.a.push('');\n        } else {\n            p.a[p.a.length - 1] += c;\n        }\n        return p;\n    }, { a: [''] }).a;\n}\n\n/**\n * Checks if the node is a document node or not.\n * @param {Node} node\n * @returns {node is Document | DocumentFragment}\n */\nfunction isDocumentNode(node) {\n    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;\n}\n\nfunction findParentOrHost(element, root) {\n    const parentNode = element.parentNode;\n    return (parentNode && parentNode.host && parentNode.nodeType === 11) ? parentNode.host : parentNode === root ? null : parentNode;\n}\n\n/**\n * Finds all elements on the page, inclusive of those within shadow roots.\n * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'\n * @return {!Array<string>} List of anchor hrefs.\n * @author ebidel@ (Eric Bidelman)\n * License Apache-2.0\n */\nexport function collectAllElementsDeep(selector = null, root, cachedElements = null) {\n    let allElements = [];\n\n    if (cachedElements) {\n        allElements = cachedElements;\n    } else {\n        const findAllElements = function(nodes) {\n            for (let i = 0, el; el = nodes[i]; ++i) {\n                allElements.push(el);\n                // If the element has a shadow root, dig deeper.\n                if (el.shadowRoot) {\n                    findAllElements(el.shadowRoot.querySelectorAll('*'));\n                }\n            }\n        }\n        if(root.shadowRoot) {\n            findAllElements(root.shadowRoot.querySelectorAll('*'));\n        }\n        findAllElements(root.querySelectorAll('*'));\n    }\n\n    return allElements.filter(el => el.matches(selector));\n}\n\n","import { querySelectorAllDeep, querySelectorDeep } from 'query-selector-shadow-dom';\n\n(function () {\n\n  const testDom = querySelectorAllDeep(\".column-cell\");\n  console.log(testDom);\n\n  async function getTitle(id) {\n    let qid = `Q${id}`;\n    let jsonData = await makeRequest(id);\n    const eninityTitle = jsonData.entities[qid].sitelinks.enwiki.title;\n    return Promise.resolve(eninityTitle);\n  }\n\n  const makeRequest = async (ID) => {\n    let wikidata = await fetch(\n      `https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&props=sitelinks&ids=Q${ID}&sitefilter=enwiki&origin=*`\n    );\n    let wikidataJson = await wikidata.json();\n    return wikidataJson;\n  };\n\n  function findAllIds() {\n    let ids = [];\n    const target = document\n      .querySelector(\"chart-legend\")\n      .querySelector(\"mp-chart-legend\")\n      .shadowRoot.querySelector(\"mp-items-menu\")\n      .shadowRoot.querySelector(\".screen-options-list\");\n    target\n      .querySelectorAll(\"*:not(script):not(noscript):not(style)\")\n      .forEach(({ childNodes: [...nodes] }) =>\n        nodes\n          .filter(({ nodeType }) => nodeType === document.TEXT_NODE)\n          .forEach(async (textNode) => {\n            const regex = new RegExp(/entityId:/);\n            if (regex.test(textNode.textContent)) {\n              const subText = textNode.textContent.split(\" \");\n              subText.forEach(async (item) => {\n                if (regex.test(item)) {\n                  const eninityArry = item.split(\":\");\n                  const eninityId = eninityArry[1].split(\" \")[0];\n                  ids.push({\n                    id: eninityId,\n                    element: textNode,\n                    preString: `entityId:${eninityId}`,\n                  });\n                }\n              });\n            }\n          })\n      );\n    return ids;\n  }\n  const ids = findAllIds();\n  const createObject = async (item) => {\n    const name = await getTitle(item.id);\n    return {\n      ...item,\n      name,\n    };\n  };\n  const getData = async () => {\n    return Promise.all(ids.map((item) => createObject(item)));\n  };\n  getData().then((data) => {\n    for (const item of data) {\n      console.log(`Replacing ${item.preString} to ${item.name}`);\n      item.element.textContent = item.element.textContent.replace(\n        item.preString,\n        item.name\n      );\n    }\n    if (data.length > 0) {\n      console.log(data);\n      console.log(data.length);\n    } else {\n      console.log(\"Nothing to replace\");\n    }\n  });\n})();\n\n"]}